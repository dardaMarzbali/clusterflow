#!/usr/bin/perl
use warnings;
use strict;
use Getopt::Long;
use FindBin qw($Bin);
use lib "$FindBin::Bin/../source";
use CF::Constants;
use CF::Helpers;
use POSIX qw(strftime);
use Cwd;

##########################################################################
# Copyright 2014, Philip Ewels (phil.ewels@babraham.ac.uk)               #
#                                                                        #
# This file is part of Cluster Flow.                                     #
#                                                                        #
# Cluster Flow is free software: you can redistribute it and/or modify   #
# it under the terms of the GNU General Public License as published by   #
# the Free Software Foundation, either version 3 of the License, or      #
# (at your option) any later version.                                    #
#                                                                        #
# Cluster Flow is distributed in the hope that it will be useful,        #
# but WITHOUT ANY WARRANTY; without even the implied warranty of         #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          #
# GNU General Public License for more details.                           #
#                                                                        #
# You should have received a copy of the GNU General Public License      #
# along with Cluster Flow.  If not, see <http://www.gnu.org/licenses/>.  #
##########################################################################


# Get Options
my $required_cores;
my $required_mem;
my $required_modules;
my $help;
my $result = GetOptions ("cores=i" => \$required_cores, "mem" => \$required_mem, "modules" => \$required_modules, "help" => \$help);
if($required_cores || $required_mem || $required_modules){
	exit;
}
if($help){
	die "\nThis is a core module which is executed when each run has finished.\n";
}


# MODULE
# Read in the input files from the run file
my ($files, $runfile, $job_id, $prev_job_id, $cores, $mem, $parameters, $config_ref) = CF::Helpers::load_runfile_params(@ARGV);
my %config = %$config_ref;
my $pipeline = $parameters->[0];
my $outfn = $parameters->[1];


# Print run finish status to outfile
my $date = strftime "%H:%M %d-%m-%Y", localtime;
warn "\n###CF Run finished at $date\n\n";

# Parse the outfile (the run logs)
my @highlights;
my @commands;
my %modules;
my %modkeys;
my $unrecognised = "";
my $i = 1;
open (IN,'<',$outfn) or die "Can't read ".getcwd()."/$outfn - $!";
while(<IN>){
	
	chomp;
	
	# Ignore crap
	if(/^Warning: no access to tty/ || /^Thus no job control in this shell/ || /sh: module: line 1: syntax error: unexpected end of file/ || /sh: error importing function definition for/){
		next;
	}
	
	# First, strip the module identifier
	if(s/^###CF_(.*?)://){
		$modules{$1} .= "$_\n";
		$modkeys{$1} = $i;
	} else {
		$unrecognised .= "$_\n";
	}
	
	# Commands run
	if(/^###CFCMD/){
		push (@commands, substr($_, 9));
		
	# Highlight statuses
	} elsif(/^###CF/){
		push (@highlights, '- '.substr($_, 6));
	}
	
	# Increment counter for module keys hash
	$i++;
	
}
close (IN);

# Make new, cleaned output
my $outfile = "";
# Go through module keys hash sorting by values (the last counter value seen)
foreach my $key (sort { $modkeys{$a} <=> $modkeys{$b} or $a cmp $b } keys %modkeys) {
	$outfile .= $modules{$key}."\n\n\n";
}
if(length($unrecognised) > 0){
	$outfile .= ("-"x80)."\nUnrecognised output:\n".("-"x80)."\n".$unrecognised;
}

# Write out the cleaned runfile without any crap
open (OUT,'>',$outfn) or die "Can't write to $outfn: $!";
print OUT $outfile;
close OUT;

# Send e-mail to submitter, if the config demands it
if($config{notifications}{run} && defined($config{email})){
	
	my $to = $config{email};
	my $subject = "'[CF] $pipeline run compete - $runfile'";
	
	my $message_body = "A run using the $pipeline pipeline has completed.

The working directory was ".getcwd()."/
The runfile is $runfile
See below for highlighted status messages and the commands that were run.

=================================
== Highlighted status messages ==
=================================
- ".join("\n- ", @highlights)."
\n\n\n\n\n
==================
== Commands run ==
==================
- ".join("\n", @commands)."


== Full log output ==
".$outfile."\n\n\n";
	


	open (PIPE , "| mail -s $subject $to") or die "can't open pipe to mail: $!\n";
	print PIPE $message_body;
	close PIPE;
	die "mail exited with a non-zero status: $?\n" if $?;
	
	# Give mail time to actually send the e-mail before qsub shuts us down
	sleep(5); 
	
	warn "###CF Sent a run e-mail notification to $to\n";

} elsif($config{notifications}{run} && !defined($config{email})){
	warn "###CF Tried to send run e-mail notification but no e-mail address found in config\n";
}


