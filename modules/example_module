#!/usr/bin/perl
use warnings;
use strict;
use Getopt::Long;
use FindBin qw($Bin);
use lib "$FindBin::Bin/../source";
use CF::Constants;
use CF::Helpers;
use File::Copy qw(move);

# Get Options
my $avail_cores;
my $avail_mem;
my $required_modules;
my $help;
my $result = GetOptions (
	"cores=i" => \$avail_cores,
	"mem=s" => \$avail_mem,
	"modules" => \$required_modules,
	"help" => \$help
);

# CF SETUP
# --cores i = offered cores. Return how many cores we need or would like.
if($avail_cores){
	print CF::Helpers::allocate_cores($avail_cores, 1, 6);
	exit;
}
# --mem s = offered memory string. Return how much memory we need or would like.
if($avail_mem){
	print CF::Helpers::allocate_memory($avail_mem, '3G', '4G');
	exit;
}
# --modules. Return comma seperated names of any environment modules which should be loaded.
if($required_modules){
	print 'example_module,sratoolkit';
	exit;
}
# --help. Print help.
if($help){
	print "".("-"x15)."\n Example Module\n".("-"x15)."\n
This is a dummy module which provides example code to be used
by anyone interested in writing their own Cluster Flow module.
It doesn't do anything, but its source code is nicely commented..\n\n";
	exit;
}

# Start the clock...
my $timestart = time;

# Read in the input files from the run file
my (
	$files,
	$runfile,
	$job_id,
	$prev_job_id,
	$cores,
	$mem,
	$parameters,
	$config_ref
) = CF::Helpers::load_runfile_params(@ARGV);
my %config = %$config_ref;

# Check that we have a genome defined
if(!defined($config{genome_path})){
	warn "\n\n###CF No genome path found in run file $runfile for job $job_id. Exiting.. ###";
	exit;
} else {
	warn "\nUsing the genome path: ".$config{genome_path}."\n\n";
}

# Sanity check for cores, shouldn't be required but can't hurt
if(!defined($cores) || $cores < 1){
	$cores = 1;
}

# Open up our run file in append mode
open (RUN,'>>',$runfile) or die "Can't write to $runfile: $!";

# Separate file names into single end and paired end
my ($se_files, $pe_files) = CF::Helpers::is_paired_end(\%config, @$files);

# Initiate the FastQ encoding type variable.
# Once we've found the encodeing for one file, we'll assume all others are the same
my $encoding = 0;

# Go through each SINGLE END file and run our command
if($se_files && scalar(@$se_files) > 0){
	foreach my $file (@$se_files){
		
		# Figure out the encoding if we don't already know
		if(!$encoding){
			($encoding) = CF::Helpers::fastq_encoding_type($file);
		}
		# Format the returned encoding type so that our program can understand it
		my $enc = "";
		if($encoding eq 'phred33' || $encoding eq 'phred64' || $encoding eq 'solexa'){
			$enc = '--'.$encoding.'-quals';
		}
		
		# Generate a nice output file name
		my $output_fn = $file."_processed.output";
		
		# Write our command!
		my $command = "my_command $enc -c $cores -m $mem -g ".$config{genome_path}." -i $file -o $output_fn";
		# Write the command to the log file
		warn "\n###CFCMD $command\n\n";
		
		# Try to run the command - returns 0 on success (which evaluated to false)
		if(!system ($command)){
			# Command worked!
			# Work out how long the processing took
			my $duration =  CF::Helpers::parse_seconds(time - $timestart);
			
			# Print a success message to the log file which will be e-mailed out
			warn "###CF Example module (SE mode) successfully exited, took $duration..\n";
			
			# Check we can find our output filename!
			if(-e $output_fn){
				# Print the current job ID and the output filename to the run file
				# This is so that subsequent modules can use this output
				print RUN "$job_id\t$output_fn\n"; 
			} else {
				# Oops - can't find the output file! Err...
				warn "\nExample module output file $output_fn not found..\n";
			}
		} else {
			# Command returned a non-zero result, probably went wrong...
			warn "\n###CF ## Example module (SE mode) failed ##\n\n";
		}
		
	}
}

# Ok - now we do it all again. This time in PAIRED END mode.
if($pe_files && scalar(@$pe_files) > 0){
	foreach my $files_ref (@$pe_files){
		my @files = @$files_ref;
		
		# Check that we do actually have two files here
		if(scalar(@files) == 2){
			
			# Figure out the encoding if we don't already know
			if(!$encoding){
				($encoding) = CF::Helpers::fastq_encoding_type($files[0]);
			}
			# Format the returned encoding type so that our program can understand it
			my $enc = "";
			if($encoding eq 'phred33' || $encoding eq 'phred64' || $encoding eq 'solexa'){
				$enc = '--'.$encoding.'-quals';
			}
			
			# Generate a nice output file name
			my $output_fn = $files[0]."_".$files[1]."_processed.output";
			
			# Write our command!
			my $command = "my_command $enc -c $cores -m $mem -g ".$config{genome_path}." -1 ".$files[0]." -2 ".$files[1]." -o $output_fn";
			# Write the command to the log file
			warn "\n###CFCMD $command\n\n";
			
			# Try to run the command - returns 0 on success (which evaluated to false)
			if(!system ($command)){
				# Command worked!
				# Work out how long the processing took
				my $duration =  CF::Helpers::parse_seconds(time - $timestart);
				
				# Print a success message to the log file which will be e-mailed out
				warn "###CF Example module (PE mode) successfully exited, took $duration....\n";
				
				# Check we can find our output filename
				if(-e $output_fn){
					# Print the current job ID and the output filename to the run file
					# This is so that subsequent modules can use this output
					print RUN "$job_id\t$output_fn\n";
				} else {
					# Oops - can't find the output file! Err...
					warn "\n###CF ## Example module output file $output_fn not found ##\n";
				}
			} else {
				# Command returned a non-zero result, probably went wrong...
				warn "\n###CF ## Example module (PE mode) failed ##\n\n";
			}
		} else {
			# We didn't have two files here..
			warn "\n###CF ## Example module paired end files had ".scalar(@files)." input files instead of 2 ##\n";
		}
		
	}
}




close (RUN);